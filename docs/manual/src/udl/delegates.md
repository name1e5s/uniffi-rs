# Delegate objects

We'll be considering the UDL for an object called `DemoRustObject`:

```webidl
interface DemoRustObject {
    void do_expensive_thing();
    [Throws=RustyError]
    void do_crashy_thing();
    string get_state_at(i32 index);
}
```

`DemoRustObject` is a `struct` written in Rust, and uniffi generates a class of that name in the foreign languages which forward method calls to the Rust implementation.

## Problem

Just by the names of these methods, we can see that the application might not want to deal with the `DemoRustObject` by itself, without some proper care taken while calling its methods.

A common pattern when using uniffied code is to run some common, but app-specific, code before or after calling the Rust code.

```kotlin
class DemoLib(
    val backgroundScope: CoroutineContext,
    val errorReporter: (e: Exception) -> Unit,
) {
    val demoRustObject = new DemoRustObject()

    fun doExpensiveThing() {
        backgroundScope.launch {
            demoRustObject.doExpensiveThing()
        }
    }

    fun doCrashyThing() {}
        try {
            demoRustObject.doCrashyThing()
        } catch (e: Exception) {
            errorReporter(e)
        }
    }

    fun getStateAt(index: Int): String =
        try {
            demoRustObject.getState(index)
        } catch (e: Exception) {
            errorReporter(e)
        }
}
```

This causes a proliferation of boiler plate code. Worse, everytime we add a new method to the `DemoRustObject`, handwritten foreign language code needs to be written to expose it safely.

The more methods that want to do similar things, the more repetitive this gets.

We could isolate the repeated code into a delegate class with `onBackgroundThread` and `withErrorReporter` methods.

We'll handwrite a little delegate interface, then write an implementation that we pass the thread pool/coroutine context/whatever, and the error reporter.

```kotlin
interface DemoDelegate {
    fun onBackgroundThread(rustCall: () -> Unit)
    fun <T> withErrorReporter(rustCall: () -> T): T
}

class MyDemoDelegate(
    val backgroundScope: CoroutineContext,
    val errorReporter: (e: Exception) -> Unit
) : DemoDelegate {
    fun onBackgroundThread(rustCall: () -> Unit) {
        backgroundScope.launch {
            rustCall()
        }
    }

    fun <T> withErrorReporter(rustCall: () -> T) =
        try {
            rustCall()
        } catch (e: Exception) {
            errorReporter(e)
        }
}
```

Then, we can re-write the `DemoLib` as:

```kotlin
class DemoLib(
    val delegate: DemoDelegate = MyDemoDelegate()
) {
    val demoRustObject = new DemoRustObject()

    fun doExpensiveThing() = delegate.onBackgroundThread {
        demoRustObject.doExpensiveThing()
    }

    fun doCrashyThing() = delegate.withErrorReporter {
        demoRustObject.doCrashyThing()
    }

    fun getStateAt(index: Int) = delegate.withErrorReporter {
        rust.getStateAt(index)
    }
}
```

This is much better, but it's still looking a bit cut and pasty. Enter delegate objects.

## Solution

```webidl
namespace demo {}

[Delegate]
interface DemoDelegate {
    any  with_error_reporter();
    void on_background_thread();
}

[Delegate=DemoDelegate]
interface DemoRustObject {
    [CallWith=on_backghround_thread]
    void do_expensive_thing();

    [Throws=RustyError, CallWith=with_error_reporter]
    void do_crashy_thing();

    [CallWith=with_error_reporter]
    string get_state_at(i32 index);
}
```

With this UDL: the `[Delegate]` annotation declares an `DemoDelegate` as a delegate object. Delegate objects never cross the FFI.

They are implemented as a `protocol` in Swift, and `interface` in Kotlin.

They declare zero argument methods, but can return an arbitrary concrete type, `void` or the generic `any` type. The `DemoDelegate` interface is now generated, to accept
a generic closure which will call the Rust code.

```kotlin
// generated by uniffi
interface DemoDelegate {
    fun <T> onBackgroundThread(rustCall: () -> T)
    fun <T> withErrorReporter(rustCall: () -> T): T
}
```

The `[Delegate=DemoDelegate]` annotation above the `DemoRustObject` `interface` declaration ties the delegate object to our original `DemoRustObject` class.

This changes the generated API of `DemoRustObject`:

* it adds a `DemoDelegate` argument to every constructor.
* it changes the return types and throws types for each method called with a delegate method to match the delegate method. Where the delegate method returns `any`, the original return type remains.

Now the generated Rust calls go through the app-specific delegate methods, we could more safely hand the rust object to the application to use directly.

```kotlin
val delegate = MyDemoDelegate(backgroundScope, errorReporter)
val demoRustObject = DemoRustObject(delegate)
```

This is a considerable improvement! Now the delegate methods can be specified by the app, and the UDL uses them. Each time the UDL changes, the foreign language bindings keeps up.

### Re-writing the wrapper

In our example above, we had a handwritten `DemoLib` which had all the methods of the `DemoRustObject` but did all error catching and launching on a background thread. It was also a good place to put additional handwritten code. There may already be a considerable amount of application code pointing to it, which we don't want to change.

Uniffi generates a Kotlin `interface` or Swift `protocol` for each `Object` in the UDL. In this case, `DemoRustObject` is the class, and `DemoRustObjectInterface` is the interface.

#### Kotlin

We can use this and [Kotlin's Interface delegation features][1] to re-write `DemoLib` so that it too keeps up and in sync with the UDL.

[1]: https://kotlinlang.org/docs/delegation.html

```kotlin
class DemoLib private constructor(
    demoRustObject: DemoRustObject
) : DemoRustObjectInterface by demoRustObject {

    constructor(delegate: DemoDelegate) = this(DemoRustObject(delegate))

    constructor(
        backgroundScope: CoroutineContext,
        errorReporter: (e: Exception) -> Unit
    ) = this(MyDemoDelegate(backgroundScope, errorReporter))
}
```

We can then add hand-written code to this class.

#### Swift

In Swift, we can't get `DemoLib` to implement `DemoRustObjectProtocol`, and automatically implement the methods with `DemoRustObject`. Instead we literally replace it with a `typealias` and add a convenience constructor to take the original arguments. Handwritten code can then be added to this extension.

```swift
typealias DemoLib = DemoRustObject
extension DemoLib {
    convenience init(
        backgroundQueue: OperationQueue,
        errorReporter: @escaping (Error) -> Void
    ) {
        self.init(
            MyDemoDelegate(
                backgroundQueue: backgroundQueue,
                errorReporter: errorReporter
            )
        )
    }
}
```
